# 알고리즘 페이지 구성 템플릿

## 1. 각 페이지가 담아야 할 7개 영역

모든 알고리즘 페이지는 아래 7개 영역으로 구성된다. 일부 영역은 선택적이다.

```
1. 헤더 (필수)
2. 메인 시각화 (필수)
3. 보조 시각화 (선택)
4. 컨트롤 바 (필수)
5. 단계 설명 (필수)
6. 개념 설명 (필수)
7. 비교 뷰 (선택)
```

---

## 2. 영역별 상세 가이드

### 2.1 헤더

```
┌──────────────────────────────────────────┐
│  Bubble Sort  버블 정렬                   │
│  인접한 두 원소를 비교하여 정렬하는 알고리즘  │
│  [O(n²)] [안정 정렬] [비교 기반]           │
└──────────────────────────────────────────┘
```

포함 요소:
- 영문명 + 한글명
- 한 줄 설명 (20자 이내)
- 복잡도 뱃지 (시간/공간)
- 특성 태그 (안정/불안정, 제자리/추가공간 등)

### 2.2 메인 시각화

알고리즘의 핵심 동작을 보여주는 메인 뷰. 알고리즘 유형별로 다른 컴포넌트를 사용한다.

| 유형 | 컴포넌트 | 예시 |
|------|---------|------|
| 정렬 | BarChartView | 막대 높이로 값 표현, 비교/교환 애니메이션 |
| 탐색 | ArrayView | 배열에서 탐색 범위 축소 과정 |
| 트리 | TreeView | 노드 삽입/삭제/탐색 경로 |
| 그래프 | GraphView | 노드/간선, 방문 상태 색상 |
| 스택/큐 | StackView/QueueView | push/pop 애니메이션 |
| DP | TableView | 셀 채우기 애니메이션 |

### 2.3 보조 시각화

메인 뷰를 보충하는 추가 정보. 메인 뷰와 나란히 배치.

| 알고리즘 | 보조 뷰 |
|---------|---------|
| 모든 정렬 | 배열 인덱스 뷰 (현재 배열 상태) |
| BFS | 큐 내용물 |
| DFS | 스택/재귀 호출 스택 |
| Dijkstra | 거리 테이블 |
| Merge Sort | 분할 트리 |
| 힙 | 배열 뷰 (1-based) |
| DP | 재귀 트리 (중복 계산 표시) |

### 2.4 컨트롤 바

(04-ux-design.md의 "컨트롤 바 설계" 참조)

### 2.5 단계 설명

현재 스텝의 동작을 한국어로 설명한다.

```
┌─ 진행 상황 ──────────────────────────────┐
│                                          │
│  [COMPARE]  스텝 3 / 12                  │
│                                          │
│  인덱스 2(43)와 인덱스 3(3) 비교           │
│  43 > 3 이므로 교환이 필요합니다            │
│                                          │
│  비교: 3회  교환: 1회                     │
│                                          │
│  ━━━━━━━━●━━━━━━━━━━━━━━━  25%           │
└──────────────────────────────────────────┘
```

포함 요소:
- 스텝 유형 뱃지 (COMPARE, SWAP, INSERT, VISIT 등)
- 현재 스텝 번호 / 전체 스텝 수
- 설명 텍스트 (무엇을 하고 있고, 왜 하는지)
- 누적 카운터 (비교 횟수, 교환 횟수)
- 진행률 바

### 2.6 개념 설명

의사코드, 핵심 포인트, 복잡도 분석을 카드/팝업으로 제공한다. 기존 힙의 FunctionExplainer와 동일한 패턴.

```
┌─ 알고리즘 상세 ─────────────────────────────────────────┐
│                                                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ 의사코드      │  │ 핵심 포인트   │  │ 복잡도 분석   │   │
│  │ bubbleSort() │  │ • 안정 정렬   │  │ 최선: O(n)   │   │
│  │ ...          │  │ • 제자리      │  │ 평균: O(n²)  │   │
│  │              │  │ • 교육용      │  │ 최악: O(n²)  │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

구성:
- **의사코드 탭**: 알고리즘 로직, 현재 실행 줄 하이라이트
- **핵심 포인트 탭**: 기억해야 할 특성 3~5개
- **복잡도 분석 탭**: 최선/평균/최악 시간 + 공간 + 이유 설명

### 2.7 비교 뷰 (선택)

같은 카테고리의 다른 알고리즘과 성능을 비교한다.

```
┌─ 알고리즘 비교 ─────────────────────────────────────┐
│                                                      │
│  같은 데이터 [38, 27, 43, 3, 9]로 비교               │
│                                                      │
│  ┌─ Bubble Sort ─┐    VS    ┌─ Selection Sort ─┐   │
│  │ ▐▐▐ ▐▐▐ ▐▐▐   │          │ ▐▐▐ ▐▐▐ ▐▐▐       │   │
│  │ 비교: 10      │          │ 비교: 10           │   │
│  │ 교환: 4       │          │ 교환: 3            │   │
│  │ 총 8스텝      │          │ 총 7스텝           │   │
│  └───────────────┘          └────────────────────┘   │
│                                                      │
│  결과: Selection Sort가 12% 적은 교환으로 완료!        │
└──────────────────────────────────────────────────────┘
```

---

## 3. 알고리즘별 설명 구조 예시

### 3.1 Bubble Sort 페이지 예시

**의사코드:**
```
function bubbleSort(arr):
  n = arr.length
  for i = 0 to n-1:
    swapped = false
    for j = 0 to n-i-2:
      if arr[j] > arr[j+1]:
        swap(arr[j], arr[j+1])
        swapped = true
    if not swapped:
      break
  return arr
```

**핵심 포인트:**
1. 인접한 두 원소를 비교하여 순서가 잘못되면 교환
2. 한 패스가 끝나면 가장 큰 값이 맨 뒤로 확정
3. 교환이 없는 패스가 있으면 조기 종료 가능 (최적화)
4. 안정 정렬: 같은 값의 순서가 보존됨

**복잡도 분석:**
| 케이스 | 시간 | 설명 |
|--------|------|------|
| 최선 | O(n) | 이미 정렬된 배열 (조기 종료) |
| 평균 | O(n²) | 랜덤 배열 |
| 최악 | O(n²) | 역순 배열 |
| 공간 | O(1) | 추가 메모리 불필요 |

**Step 유형:**
| type | 색상 | 의미 |
|------|------|------|
| compare | 주황 | 두 인접 원소 비교 |
| swap | 빨강 | 순서 잘못됨 → 교환 |
| pass-complete | 초록 | 한 패스 완료, 마지막 원소 확정 |
| complete | 초록 | 전체 정렬 완료 |

---

### 3.2 BFS 페이지 예시

**의사코드:**
```
function BFS(graph, start):
  queue = [start]
  visited = {start}
  while queue is not empty:
    node = queue.dequeue()
    for neighbor in graph[node]:
      if neighbor not in visited:
        visited.add(neighbor)
        queue.enqueue(neighbor)
  return visited
```

**핵심 포인트:**
1. 큐를 사용하여 레벨 순서로 탐색
2. 가중치 없는 그래프에서 최단 경로 보장
3. 모든 노드를 방문: O(V + E)
4. 방문 체크를 하지 않으면 무한 루프 위험

**Step 유형:**
| type | 색상 | 의미 |
|------|------|------|
| dequeue | 주황 | 큐에서 노드 꺼냄 |
| visit | 초록 | 노드 방문 완료 |
| enqueue | 파랑 | 이웃 노드를 큐에 추가 |
| skip | 회색 | 이미 방문한 노드 건너뜀 |
| complete | 초록 | 탐색 완료 |

---

## 4. 컨텐츠 작성 체크리스트

새 알고리즘 페이지를 추가할 때마다 확인할 항목:

### 로직 (algorithms/ 폴더)
- [ ] 알고리즘 로직이 올바른가
- [ ] 모든 스텝이 생성되는가 (비교, 교환, 방문 등)
- [ ] 각 스텝에 한국어 설명이 있는가
- [ ] 각 스텝에 pseudocodeLine이 매핑되어 있는가
- [ ] 에지 케이스 처리 (빈 배열, 원소 1개, 이미 정렬됨 등)

### 뷰 (pages/ 폴더)
- [ ] 메인 시각화가 알고리즘 동작을 명확히 보여주는가
- [ ] 하이라이트 색상이 일관적인가
- [ ] 보조 뷰가 필요한 경우 구현되었는가
- [ ] 프리셋 데이터가 의미 있는 시나리오를 보여주는가

### 설명 (AlgorithmMeta)
- [ ] 한 줄 설명이 20자 이내인가
- [ ] 의사코드가 구현과 일치하는가
- [ ] 핵심 포인트가 3~5개인가
- [ ] 복잡도가 올바른가 (최선/평균/최악/공간)
- [ ] 비교 대상 알고리즘이 지정되었는가

### 통합
- [ ] Sidebar에 추가되었는가
- [ ] HomePage 카드에 추가되었는가
- [ ] 라우트가 등록되었는가
- [ ] `pnpm build && pnpm lint` 통과하는가
